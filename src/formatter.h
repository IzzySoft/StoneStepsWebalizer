/*
webalizer - a web server log analysis program

Copyright (c) 2004-2017, Stone Steps Inc. (www.stonesteps.ca)

See COPYING and Copyright files for additional licensing and copyright information

formatter.h
*/
#ifndef FORMATTER_H
#define FORMATTER_H

#include "tstring.h"
#include "exception.h"

#include <cstddef>
#include <stack>
#include <vector>

//
// buffer_formatter_t
//
// buffer_formatter_t uses a formatting function passed into the format method to 
// generate formatted text within the buffer of a given size associated with each 
// instance of a buffer formatter.
//
// Using a formatting function in the format method makes it possible to use different 
// formatting functions with the same formatter and buffer.
//
// The formatter does not own the buffer and will leave the buffer intact when the
// formatter is destroyed.
//
// The formatter supports two formatting modes - overwrite and append. The former 
// uses the same buffer space every time the format method is called and the latter
// keeps adding formatted text to the unused space within the existing buffer.
//
// A scoped formatter may be used to switch the formatter mode temporarily. For example, 
// cp1 and cp2 below will be formatted within the same buffer space, while cp3 and 
// cp4 will be formatted one after another (note the comma after set_scope_mode is 
// called):
//
//    buffer_formatter_t<x> format(buffer, bufsize, buffer_formatter_t<x>::overwrite);
//
//    printf("%s\n", format(fmt_func, cp1));
//    printf("%s\n", format(fmt_func, cp2));
//
//    format.set_scope_mode(buffer_formatter_t<x>::append),
//    printf("%s %s\n", format(fmt_func, cp3), format(fmt_func, cp4));
//
// Instances of buffer_formatter_t cannot be copied because the formatting buffer is
// supplied externally and there would be no buffer for the copy. Reusing the unused
// space within the copy of the original formatter would be error-prone because the
// original formatter could overwrite formatter text generated by a copy formatter.
//
// A formatting function or a function call operator of some object that is passed 
// into the template format method is expected to have this signature:
//
//    size_t formatcb(string_t::char_buffer_t&, format_param_t ...);
//
// The character buffer object passed into the formatting function will hold formatted 
// text after the function returns. The function should return the number of characters 
// in the new formatted text, including the null character, if there is one. The formatter 
// does not interpret or modify the formatted string in any way. There is no error value 
// reserved and the function should throw an exception in case of any error.
//
class buffer_formatter_t {
   public:
      //
      // mode_t defines how the formatter uses the available buffer space
      //
      enum mode_t {overwrite, append};

      //
      // scope_t keeps track of the current formatter state in the associated C++ scope.
      // All scope_t instances returned by a formatter refer to that formatter, which 
      // actually maintains all intermediate formatter states.
      //
      // scope_t only supports move semantics, so only one formatter state is popped for 
      // every scope_t instance returned by buffer_formatter_t::set_scope_mode.
      //
      class scope_t {
         private:
            buffer_formatter_t   *formatter;          // the formatter that created this scope

            size_t               scopeid;             // scope identifier

         public:
            scope_t(const scope_t& other) = delete;
            scope_t& operator = (const scope_t& other) = delete;

            scope_t(buffer_formatter_t& formatter, size_t scopeid) : formatter(&formatter), scopeid(scopeid) 
            {
            }

            scope_t(scope_t&& other) : formatter(other.formatter), scopeid(scopeid)
            {
               // leave scopeid in the other formatter for troubleshooting
               other.formatter = NULL;
            }

            ~scope_t(void) 
            {
               if(formatter)
                  formatter->pop_scope(scopeid);
            }

            scope_t& operator = (scope_t&& other)
            {
               formatter = other.formatter;
               scopeid = other.scopeid;

               // leave scopeid in the other formatter for troubleshooting
               other.formatter = NULL;

               return *this;
            }
      };

   private:
      //
      // Every time a new formatter scope is created, the original formatter state
      // is pushed onto a stack in a fmt_state_t descriptor.
      //
      struct fmt_state_t {
         char        *cptr;            // buffer_formatter_t::cptr
         mode_t      mode;             // buffer_formatter_t::mode

         fmt_state_t(char *cptr, mode_t mode) : cptr(cptr), mode(mode) {}
      };

   private:
      char           *const buffer;    // start of the buffer
      char           *cptr;            // first unused byte
      const size_t   bufsize;          // size of the entire buffer
      mode_t         mode;             // move cptr forward after each format call?

      std::stack<fmt_state_t, std::vector<fmt_state_t>> scopes;  // saved formatter scope state descriptors

   private:
      void pop_scope(size_t scopeid);

   public:
      buffer_formatter_t(const buffer_formatter_t& other) = delete;
      buffer_formatter_t& operator = (const buffer_formatter_t& other) = delete;

      buffer_formatter_t(char *buffer, size_t bufsize, mode_t mode);

      template <typename format_cb_t, typename ... format_param_t>
      string_t::char_buffer_t format(format_cb_t&& formatcb, format_param_t&& ... arg);

      template <typename format_cb_t, typename ... format_param_t>
      const char *operator () (format_cb_t&& formatcb, format_param_t&& ... arg);

      void set_mode(mode_t newmode) {mode = newmode;}

      scope_t set_scope_mode(mode_t newmode);
};

#endif // FORMATTER_H
